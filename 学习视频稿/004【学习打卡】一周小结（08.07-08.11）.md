## 学习打卡|一周小结（08.07-08.11）

这周我主要在极客时间学一个WebAssembly入门课，特别巧，我在极客时间上刚学完了Vue3的全家桶，然后在首页看到了推荐的WebAssembly课程，我想，入门课嘛，应该不难，就看看呗。

### 缘由

关于WebAssembly，在多年前我就有所耳闻，当时对它的了解仅仅是可以使C或者Java之类的语言编写的代码经过编译后可以运行在浏览器上，因为没怎么见过讨论，所以当时我就没怎么放在心上。

然后是两年前，我参加了一次字节的面试，在面试的最后，面试官问了我一个问题，问我有没有了解过WebAssembly，抱歉，还真没有。

那就来了解一下呗。

### 前置知识

课程的最开始介绍了一些基础知识。

#### JavaScript

首先是JavaScript，看了之后呢，我理解是JavaScript对性能的追求，比如requestAnimationFrame，是为了优化js动画性能，以前我们编写JavaScript动画，通常会使用setTimeout或者setInterval这类计时器，但因为js的单线程模型以及浏览器事件循环模型，使用这类计时器可能会造成丢帧或卡顿，使用requestAnimationFrame可以提升这方面的体验，将会在浏览器重新绘制当前帧动画前调用其回调函数；除此之外，requestAnimationFrame也做了其他方面的性能优化，比如页面为非激活状态时，动画会暂停。

然后是Performance API，也是方便开发人员对性能进行调优。

这两块内容，部分地回答了WebAssembly出现的原因，便是前端对性能的追求。

再然后是TypedArray，TypedArray不同于传统的JavaScript数组，可以用来与底层数据进行打交道。

#### C/C++

接着是C/C++的一些东西，C作为计算机专业基础课，那我还是学过的，但是C++嘛，由于我当年上学时选的是Web方向，所以就还真没有学过，只记得好像是和Java一样，有类的概念，其他的就不太清楚了，课程里主要介绍了`extern "C" {}`这个语法结构，主要是为了解决Name Mangling的问题；那什么是Name Mangling呢？这与C++的函数重载有关，函数重载使得C++源代码中可以存在同名但是参数不同的函数，但是经过编译后，这些同名函数在Name Mangling的作用下，会生成不同的标识符，为了保持标识符名称不变，就可以使用`extern "C" {}`这个语法结构对代码进行包裹，强制以C语言的语法规则，来编译这个作用域内的C++源代码，因为C语言中没有函数重载的特性。

然后是与编译有关的内容，DCE，DCE是一种编译优化技术，会消除那些对程序最后运行结果没有任何影响的代码，这有点像前端里面的Tree-Shaking技术，也是在构建打包时会移除没有用到的代码。

再是编译优化等级的配置，O1、O2、O3、O4这些；O0是默认的编译优化等级，保留最多的调试性信息，一般用于调试和本地开发。O3、O4一般用于”生产版本“。

#### 计算机基础知识

最后是计算机的部分基础知识。

首先，原码、反码和补码。说实话，有点点记不太清。

前几周我参加了一个考试，内容有计算机基础知识，刚好考到补码的问题，在转反码的时候，我发现自己不记得符号位要不要取反了，考试结果肯定是一塌糊涂，趁此机会我就当做复习一下基础知识吧，顺便补习了一下为什么补码可以用于负数，才想起来吧是利用了最高位溢出。

然后是ACL，Access Control List，访问控制列表。扯了一下权限。

### 为什么会有WebAssembly

#### JavaScript的缺陷

为什么会有WebAssembly？

从前置知识里，我们可以知道，JavaScript语言和浏览器一直在尝试追求更优的性能，这也是WebAssembly的主要目标之一。WebAssembly能发展起来，部分原因在于JavaScript本身存在的一些问题。

首先，Web应用规模的急速增长。现代Web应用承载了大量功能，加上为兼容旧版本浏览器生成的各类Polyfill代码，因此应用变得越来越复杂，体积也日益庞大，因此在实际运行时，会影响整体运行效率。

其次，JavaScript的弱类型；导致在实际运行时才进行变量类型的推导，会带来额外的运行时性能开销。尽管现在JavaScript引擎使用了一些优化技术，但这个优化过程本身也会产生一些消耗。

#### 曾经的尝试

在WebAssembly之前，曾经有过一些尝试。

比如NaCl与PNaCl，以及ASM.js，它们主要有三点共同特征：

1. 源码中使用类型明确的变量
    
2. 应用都拥有独立的运行时环境，与JavaScript运行时环境分离
    
3. 支持将C/C++应用通过某种方式转换到基于这些技术的实现，从而可以直接在浏览器中运行
    

在设计和实现wasm时，参考了很多从这两种技术中总结下来的优缺点。

基于以上了解，使用WebAssembly的还有一个好处，就是可以复用优秀的C/C++库。

### WebAssembly是什么

WebAssembly，简称wasm。

官方的描述是：一种基于堆栈式虚拟机的二进制指令集，一种编程语言的可移植编译目标，可以通过将其部署到Web平台上，为客户端及服务端应用程序提供服务。

根据这个描述，有以下几个认知：

第一，指令集，可以联想到汇编指令

第二，基于堆栈式虚拟机，联系堆栈机这个计算模型，得知指令的基本结构，指令，然后后面紧跟着操作数

第三，编程语言的编译目标，可知wasm设计的目标主要不是用于手写，虽然其有”助记符“的形式

第四，基于虚拟机、可移植，可知wasm可移植主要在于它运行在虚拟机环境

### wasm模块两种格式

继续了解wasm模块。

#### 字节码格式

首先是字节码格式，介绍了wasm二进制模块的组成结构。

##### 组成结构

首先是内容的主要结构，包括12种Section，分别存储了有关模块的不同数据或功能的信息。除了自定义Section以外，其他11种Section需要按照其给定的ID，顺序排列。每种Section拥有通用头部header，提供了关于其本身及其内容的描述性信息，比如id，有效载荷大小，自定义Section的名称等，header后面紧跟的就是对应Section的有效载荷数据payload_data。

为了使虚拟机能够对wasm模块进行识别，wasm使用魔数来标记其二进制文件，并使用版本号来标记版本，这两个标记位于wasm模块二进制代码最开始的位置。

另外，我们可以使用`hexdump`等命令来查看二进制文件的字节码内容

##### 二进制编码

由于字节码的内容是编码后的结果，顺带复习了下二进制编码的内容。

用于整数的LEB-128编码，用于浮点数的IEEE-754编码，以及用于字符的UTF-8编码。

#### WAT可读文本格式

WAT与wasm字节码具有完全等价的表达能力，不同之处在于它更易于被人阅读。

WAT使用”S- 表达式“的形式来表达wasm模块及其定义。

在”S- 表达式“中，使用一对小括号`()`来定义每一个表达式的结构，表达式的第一个元素，表示将要执行的”操作“，后边跟着的就是对应该操作的具体操作”内容”。比如这段Lisp代码：

```lisp
(print  
 (* 2 (+ 3 4))  
 )
```

这就让我联想到前面提到的堆栈机模型指令的基本结构，也是`指令` ，后面紧跟着操作数。

WAT的执行顺序是从最内层的括号表达式开始，从内到外，最后计算出整个表达式的值。

为了使WAT文本内容更直观，表达“从上到下”的执行顺序，出现了Flat-WAT，目的就是将WAT中的嵌套以及括号结构去掉，这样就可以看到Flat-WAT代码与wasm字节码直观的”一对一“关系。

然后是介绍了几个可以用来与WAT格式打交道的工具，来自于名为WABT的wasm二进制格式工具集。

我尝试了一下`wasm2wat`的命令，貌似输出的WAT代码中函数部分已经是Flat-WAT格式文本。

学的有点慢，暂时先到这里啦，实践一下费曼学习法。