## HTTP常见响应状态码

引言：

作为前端，大家一定对HTTP响应不陌生，因为页面展示需要向服务器发起HTTP请求，而渲染和交互的内容都是从请求的响应中解析而来；但是由于网络的不稳定性、HTTP对请求的优化等等之类的原因，并不一定每次响应都能正确并完整地返回所请求的内容，所以HTTP针对不同的响应状态预定义了部分状态码，以便于客户端在处理请求所返回的响应时，能根据状态码来进行分类处理；所以前端很有必要对常见的状态码有所了解，以便于判断并处理异常状态，从而优化用户体验。



### 状态码分类

根据RFC文档的描述，HTTP响应状态码分为5类，

1xx

2xx

3xx

4xx

5xx。

他们对应的含义分别是：

* 1打头的状态码是信息性的内容，表示请求已经被接收，继续处理中
* 2打头的状态码是请求成功的意思，表示请求已被成功地接收、理解和接受
* 3打头的状态码是重定向的意思，表示需要采取进一步行动才能完成请求
* 4打头的状态码是客户端错误的意思，表示请求中包含了错误语法或者无法满足
* 5打头的状态码是服务器错误的意思，表示请求是合法的，但服务器无法满足

可以看出，状态码的第一位数字定义了响应的类别，但后两位数是没有分类作用的。



### 常见状态码

我根据deepL和自己的理解大致简单梳理了一遍RFC的文档，但我们并没必要去背诵或怎样，因为实际常用的也就其中的几个，我们只要掌握常用的状态码就可以，比如200、404、304、500等等，我看RFC文档上对于3打头的状态码描述的更详细一些，也可以稍微了解一下，实际上除了304，其他3打头的状态码我个人也很少在实际项目中有碰到。

#### 1xx

1打头的是一些信息性的临时响应，表示请求还在处理中，响应中不包含内容，所以通常不需要做什么处理

#### 200

再看200，应该是最常见的吧，代表按照预期返回响应内容

#### 3xx

然后接着来看3打头的几个状态码。

301/302 vs 308/307

这两组状态码经常在面试中会用于比较，他们的描述也基本一致，比如：

301的状态短语是永久性移动，而308的状态短语是永久重定向，都代表目标资源被分配了新的永久性URI。

那么既然已经有301了，为什么还要有308呢，那肯定是有原因的，可以看到文档中写的很明白：

针对301的响应，用户代理可以在后续请求中将请求方法由POST改为GET。所以这就是他们最主要的区别。所以如果不希望这类情况发生，那么就可以使用308来替代。另外308这里还标注了注意事项，由于相对比其他同类状态码，308是一个比较新的状态码，是在2014年6月新增的，可能无法在所有地方被识别，不过我想现在都2023年了，无法识别的地方应该很少了吧。

同理302和307的区别也是一样的，就是用户代理在后续请求中是否可以修改请求方法。



302/307 vs 301/308

接着看这组，也是很容易在面试中被用于对比的。

302的状态短语是找到，307的状态短语是临时重定向，这两个状态码的描述差不多，都表示的是目标资源暂时位于一个不同的URI下；既然是暂时的，就说明虽然这次可以通过这个临时URI地址获取内容，但不保证后续也可以，所以客户端在之后的请求中应该继续使用原来的目标URI，而不是使用响应头中的Location字段值中所包含的URI。

再看301和308，301的状态短语是永久性移动，308的状态短语是永久重定向，就从短语中我们也可以看出，表示的是目标资源被分配了一个新的永久性URI；既然是永久性的，说明之后我们可以直接通过这个新的URI获取目标资源，所以服务器通过这两种状态码，就是建议有链接编辑能力的用户代理使用服务器发送的新引用之一永久性替换对目标URI的引用；如果客户端后续还是使用原来的目标URI去请求目标资源，用户代理可以直接替换去请求新的目标URI去完成资源的获取。

所以这组状态码的区别就在于，是否使用新的目标URI永久性替换对旧的目标URI的引用。当然这都只是服务器的建议，出于安全性的考虑，用户代理可能会忽略301和308这种永久性替换的建议。



304

304状态码在浏览器缓存的那个视频中有提到过，304的状态短语是未修改，表示目标资源未修改，提示客户端可以直接使用本地的缓存，所以304的响应与缓存的使用有关。

收到304响应的前提有两个，第一个是请求头中包含了待判断的条件，比如If-Modified-Since、If-None-Match这两个字段，如果这两个条件被判断为假，客户端就会收到304响应。

第二个前提是，在客户端第一次请求或缓存过期后重新请求时，服务器返回的200响应中，需要包含ETag、Cache-Control等字段，这样就相当于开启缓存验证，再下一次请求时，请求头中才能带上相应的字段去进行条件判断



#### 4xx

接下来看4打头的状态码。

404

4打头的状态码中404是最为人所知的，甚至对很多不做开发不做技术的人都不陌生，表示资源未找到，通常我们碰到这种，很大可能是资源被删除了，当然在开发过程中也有可能是请求地址写错了。

对于404错误，RFC中将它归类为客户端错误，看上去更倾向于将这个结果解释为客户端错误地请求了一个不存在的资源。

有个与404很类似的状态码是410，状态短语是消失，两者的区别主要在于，404无法确认找不到目标资源这种情况是否是永久性的，而410代表找不到的这个情况很可能是永久性的，410响应主要用于通知客户端该资源不可用，希望指向该资源的链接被删除，主要用于协助网页维护。



401 vs 403

401和403按照文档的描述，感觉像同一类，都属于访问权限不足，不同的点在于，401是缺乏用于身份验证的凭据或者服务器拒绝对请求中包含的凭据授权；403则直接就是拒绝满足请求，如果有可公开的原因，可以在响应内容中进行描述。



其他

4打头的很多响应都是向客户端反馈，他们需要对发送的请求做部分调整修改，才能得到服务器的正常响应。

比如400 Bad Request，表示客户端的请求可能存在语法错误等问题；405方法不允许，表示客户端的请求方法不受目标资源支持；411需要长度，表示请求中缺少Content-Length字段；413内容过大，请求内容超出了服务器的处理能力；414 URI过长，表示目标URI过长超出了服务器的处理范围；415不支持的媒体类型，表示Content-Type或Content-Encoding字段指定的内容格式不被支持。

所以4xx的状态码短语虽然是客户端错误，但意思并不是说客户端发生错误了，只是说作为发起请求的一方，客户端需要对请求头或请求体的内容做一些调整。



#### 5xx

接下来看5打头的状态码，5打头代表服务器出现了一些问题。

500 / 503

比如500就是常见的表示内部服务器错误的响应，表示服务器碰到了意外的情况，这个时候可能并不知道是个什么意外情况。

如果碰到的是503状态码，表示的也是服务不可用，但503是暂时性的，是由于暂时超载或计划性维护而无法处理请求。



502 / 504

502不良网关和504网关超时，表示接收请求的服务器，他本身不提供目标资源，而是一个网关或代理的角色，他们向客户端返回的状态码502或504，表示他们本身在转发请求后收到了无效响应或者没有及时收到响应，所以没有办法正常响应客户端的请求。



### 总结

好了，视频内容到这就差不多了，作为前端开发人员，我们并不需要熟记所有状态码，现在查阅文档也很方便，但是对于常见的一些还是有必要掌握的，也有助于我们日常工作中排查问题。



